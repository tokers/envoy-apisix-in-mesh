{
  "kind": "ConfigMap",
  "apiVersion": "v1",
  "metadata": {
    "name": "envoy-apisix-configmap-2",
    "creationTimestamp": null
  },
  "data": {
    "redirect.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal core = require(\"apisix.core\")\nlocal tab_insert = table.insert\nlocal tab_concat = table.concat\n-- need to implement core.re\nlocal re_gmatch = string.gmatch\nlocal ipairs = ipairs\n\n\n-- need to implement core.log\n-- can't use lrucache currently\n-- local lrucache = core.lrucache.new({\n--     ttl = 300, count = 100\n-- })\n\n\nlocal schema = {\n    type = \"object\",\n    properties = {\n        ret_code = {type = \"integer\", minimum = 200, default = 302},\n        uri = {type = \"string\", minLength = 2},\n        http_to_https = {type = \"boolean\"}, -- default is false\n    },\n    oneOf = {\n        {required = {\"uri\"}},\n        {required = {\"http_to_https\"}}\n    }\n}\n\n\nlocal plugin_name = \"rewrite\"\n\nlocal _M = {\n    version = 0.1,\n    priority = 900,\n    name = plugin_name,\n    schema = schema,\n}\n\n\nlocal function parse_uri(uri)\n    -- regular expression doesn't work here now\n    local reg = [[ (\\\\\\$[0-9a-zA-Z_]+) | ]]         -- \\$host\n                .. [[ \\$\\{([0-9a-zA-Z_]+)\\} | ]]    -- ${host}\n                .. [[ \\$([0-9a-zA-Z_]+) | ]]        -- $host\n                .. [[ (\\$|[^$\\\\]+) ]]               -- $ or others\n    local iterator, err = re_gmatch(uri, reg, \"jiox\")\n    if not iterator then\n        return nil, err\n    end\n\n    local t = {}\n    while true do\n        local m, err = iterator()\n        if err then\n            return nil, err\n        end\n\n        if not m then\n            break\n        end\n\n        tab_insert(t, m)\n    end\n\n    return t\nend\n\n\nfunction _M.check_schema(conf)\n    -- not works now. need to implement core.schema\n    local ok, err = core.schema.check(schema, conf)\n    if not ok then\n        return false, err\n    end\n\n    if conf.uri then\n        local uri_segs, err = parse_uri(conf.uri)\n        if not uri_segs then\n            return false, err\n        end\n    end\n\n    return true\nend\n\n\n    local tmp = {}\nlocal function concat_new_uri(uri, ctx)\n    local passed_uri_segs, err = lrucache(uri, nil, parse_uri, uri)\n    if not passed_uri_segs then\n        return nil, err\n    end\n\n    core.table.clear(tmp)\n\n    for _, uri_segs in ipairs(passed_uri_segs) do\n        local pat1 = uri_segs[1]    -- \\$host\n        local pat2 = uri_segs[2]    -- ${host}\n        local pat3 = uri_segs[3]    -- $host\n        local pat4 = uri_segs[4]    -- $ or others\n\n        if pat2 or pat3 then\n            tab_insert(tmp, ctx.var[pat2 or pat3])\n        else\n            tab_insert(tmp, pat1 or pat4)\n        end\n    end\n\n    return tab_concat(tmp, \"\")\nend\n\n\nfunction _M.rewrite(conf, ctx)\n    local ret_code = conf.ret_code\n    local uri = conf.uri\n    local handle = ctx.handle\n\n    if conf.http_to_https and ctx.var.scheme == \"http\" then\n        -- TODOï¼š add test case\n        -- PR: https://github.com/apache/apisix/pull/1958\n        uri = \"https://$host$request_uri\"\n        ret_code = 301\n    end\n\n    if uri and ret_code then\n        -- local new_uri, err = concat_new_uri(uri, ctx)\n        -- if not new_uri then\n        --     core.log.error(\"failed to generate new uri by: \", uri, \" error: \",\n        --                    err)\n        --     return 500\n        -- end\n\n        -- todo \n        handle:respond(\n            {[\":status\"] = ret_code,\n            [\"Location\"] = uri,\n            [\"server\"] = \"apisix\"},\n\n            \"nope\")\n\n        --- need to implement core.respond\n        -- core.response.set_header(\"Location\", new_uri)\n\n        return ret_code\n    end\nend\n\n\nreturn _M\n",
    "referer-restriction.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal ipairs    = ipairs\nlocal core      = require(\"apisix.core\")\nlocal net_url   = require(\"net.url\")\nlocal lrucache  = core.lrucache.new({\n    ttl = 300, count = 512\n})\n\n\nlocal schema = {\n    type = \"object\",\n    properties = {\n        bypass_missing = {\n            type = \"boolean\",\n            default = false,\n        },\n        whitelist = {\n            type = \"array\",\n            items = core.schema.host_def,\n            minItems = 1\n        },\n    },\n    required = {\"whitelist\"},\n    additionalProperties = false,\n}\n\n\nlocal plugin_name = \"referer-restriction\"\n\n\nlocal _M = {\n    version = 0.1,\n    priority = 2990,\n    name = plugin_name,\n    schema = schema,\n}\n\n\nfunction _M.check_schema(conf)\n    return core.schema.check(schema, conf)\nend\n\n\nlocal function match_host(matcher, host)\n     if matcher.map[host] then\n        return true\n    end\n    for _, h in ipairs(matcher.suffixes) do\n        if core.string.has_suffix(host, h) then\n            return true\n        end\n    end\n    return false\nend\n\n\nlocal function create_host_matcher(hosts)\n    local hosts_suffix = {}\n    local hosts_map = {}\n\n    for _, h in ipairs(hosts) do\n        if h:byte(1) == 42 then -- start with '*'\n            core.table.insert(hosts_suffix, h:sub(2))\n        else\n            hosts_map[h] = true\n        end\n    end\n\n    return {\n        suffixes = hosts_suffix,\n        map = hosts_map,\n    }\nend\n\n\nfunction _M.access(conf, ctx)\n    local block = false\n    local referer = ctx.var.referer\n    local handle = ctx.handle\n    handle:logWarn(\"referer:\" .. referer)\n    if referer then\n        -- parse_uri doesn't support IPv6 literal, it is OK since we only\n        -- expect hostname in the whitelist.\n        -- See https://github.com/ledgetech/lua-resty-http/pull/104\n        local uri = net_url.parse(referer)\n        if not uri then\n            -- malformed Referer\n            referer = nil\n        else\n            -- take host part only\n            referer = uri.host\n        end\n    end\n\n    handle:logWarn(\"referer parsed:\" .. referer)\n\n\n    if not referer then\n        block = not conf.bypass_missing\n\n    elseif conf.whitelist then\n        local matcher = lrucache(conf.whitelist, nil,\n                                 create_host_matcher, conf.whitelist)\n        block = not match_host(matcher, referer)\n    end\n\n    if block then\n        return 403, { message = \"Your referer host is not allowed\" }\n    end\nend\n\n\nreturn _M\n",
    "uri-blocker.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal core = require(\"apisix.core\")\n-- local re_compile = require(\"resty.core.regex\").re_match_compile\nlocal re_find = string.find -- ngx.re.find\nlocal ipairs = ipairs\n\nlocal schema = {\n    type = \"object\",\n    properties = {\n        block_rules = {\n            type = \"array\",\n            items = {\n                type = \"string\",\n                minLength = 1,\n                maxLength = 4096,\n            },\n            uniqueItems = true\n        },\n        rejected_code = {\n            type = \"integer\",\n            minimum = 200,\n            default = 403\n        },\n    },\n    required = {\"block_rules\"},\n}\n\n\nlocal plugin_name = \"uri-blocker\"\n\nlocal _M = {\n    version = 0.1,\n    priority = 2900,\n    name = plugin_name,\n    schema = schema,\n}\n\n\nfunction _M.check_schema(conf)\n    local ok, err = core.schema.check(schema, conf)\n    if not ok then\n        return false, err\n    end\n\n    for i, re_rule in ipairs(conf.block_rules) do\n        local ok, err = re_compile(re_rule, \"j\")\n        -- core.log.warn(\"ok: \", tostring(ok), \" err: \", tostring(err),\n        --               \" re_rule: \", re_rule)\n        if not ok then\n            return false, err\n        end\n    end\n\n    return true\nend\n\n\nfunction _M.rewrite(conf, ctx)\n    -- core.log.info(\"uri: \", ctx.var.request_uri)\n    -- core.log.info(\"block uri rules: \", conf.block_rules_concat)\n\n    if not conf.block_rules_concat then\n        local block_rules = {}\n        for i, re_rule in ipairs(conf.block_rules) do\n            block_rules[i] = re_rule\n        end\n\n        conf.block_rules_concat = core.table.concat(block_rules, \"|\")\n        -- core.log.info(\"concat block_rules: \", conf.block_rules_concat)\n    end\n\n    local handle = ctx.handle\n    handle:logWarn(\"request_uri:\" .. ctx.var.request_uri .. \" conf.block_rules_concat: \" .. conf.block_rules_concat)\n\n    local from = re_find(ctx.var.request_uri, \"[\" .. conf.block_rules_concat .. \"]\") -- , \"jo\"\n\n    handle:logWarn(\"from:\" .. from)\n\n    if from then\n        return conf.rejected_code\n    end\nend\n\n\nreturn _M\n"
  }
}