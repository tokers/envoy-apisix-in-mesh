{
  "kind": "ConfigMap",
  "apiVersion": "v1",
  "metadata": {
    "name": "envoy-apisix-configmap-0",
    "creationTimestamp": null
  },
  "data": {
    "ctx.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal _M = {version = 0.2}\n\n--- Note: envoy doesn't support context for lua currently. using a global var as ctx temporarily.\n--- TODO: need a better implement and more vars\nlocal var = {}\nfunction _M.set_vars_meta(ctx, handler)\n    table.clear(var)\n    local headers = handler:headers()\n    for key, value in pairs(headers) do\n        if key == \":authority\" then\n            var.host = value\n        elseif key == \":path\" then\n            var.request_uri = value\n        elseif key == \":method\" then\n            var.method = value\n        elseif key == \"x-forwarded-proto\" then\n            var.schema = value\n        else\n            var[key] = value\n        end\n    end\n    ctx.var = var\nend\n\n\nreturn _M\n",
    "json.lua": "--\n-- json.lua\n--\n-- Copyright (c) 2020 rxi\n--\n-- Permission is hereby granted, free of charge, to any person obtaining a copy of\n-- this software and associated documentation files (the \"Software\"), to deal in\n-- the Software without restriction, including without limitation the rights to\n-- use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies\n-- of the Software, and to permit persons to whom the Software is furnished to do\n-- so, subject to the following conditions:\n--\n-- The above copyright notice and this permission notice shall be included in all\n-- copies or substantial portions of the Software.\n--\n-- THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n-- IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n-- FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n-- AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n-- LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n-- OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE\n-- SOFTWARE.\n--\nlocal string   = string\nlocal error    = error\nlocal rawget   = rawget\nlocal next     = next\nlocal pairs    = pairs\nlocal type     = type\nlocal ipairs   = ipairs\nlocal table    = table\nlocal math     = math\nlocal tostring = tostring\nlocal select   = select\nlocal tonumber = tonumber\n\nlocal json = { _version = \"0.1.2\" }\n\n-------------------------------------------------------------------------------\n-- Encode\n-------------------------------------------------------------------------------\n\nlocal encode\n\nlocal escape_char_map = {\n  [ \"\\\\\" ] = \"\\\\\",\n  [ \"\\\"\" ] = \"\\\"\",\n  [ \"\\b\" ] = \"b\",\n  [ \"\\f\" ] = \"f\",\n  [ \"\\n\" ] = \"n\",\n  [ \"\\r\" ] = \"r\",\n  [ \"\\t\" ] = \"t\",\n}\n\nlocal escape_char_map_inv = { [ \"/\" ] = \"/\" }\nfor k, v in pairs(escape_char_map) do\n  escape_char_map_inv[v] = k\nend\n\n\nlocal function escape_char(c)\n  return \"\\\\\" .. (escape_char_map[c] or string.format(\"u%04x\", c:byte()))\nend\n\n\nlocal function encode_nil(val)\n  return \"null\"\nend\n\n\nlocal function encode_table(val, stack)\n  local res = {}\n  stack = stack or {}\n\n  -- Circular reference?\n  if stack[val] then error(\"circular reference\") end\n\n  stack[val] = true\n\n  if rawget(val, 1) ~= nil or next(val) == nil then\n    -- Treat as array -- check keys are valid and it is not sparse\n    local n = 0\n    for k in pairs(val) do\n      if type(k) ~= \"number\" then\n        error(\"invalid table: mixed or invalid key types\")\n      end\n      n = n + 1\n    end\n    if n ~= #val then\n      error(\"invalid table: sparse array\")\n    end\n    -- Encode\n    for i, v in ipairs(val) do\n      table.insert(res, encode(v, stack))\n    end\n    stack[val] = nil\n    return \"[\" .. table.concat(res, \",\") .. \"]\"\n\n  else\n    -- Treat as an object\n    for k, v in pairs(val) do\n      if type(k) ~= \"string\" then\n        error(\"invalid table: mixed or invalid key types\")\n      end\n      table.insert(res, encode(k, stack) .. \":\" .. encode(v, stack))\n    end\n    stack[val] = nil\n    return \"{\" .. table.concat(res, \",\") .. \"}\"\n  end\nend\n\n\nlocal function encode_string(val)\n  return '\"' .. val:gsub('[%z\\1-\\31\\\\\"]', escape_char) .. '\"'\nend\n\n\nlocal function encode_number(val)\n  -- Check for NaN, -inf and inf\n  if val ~= val or val \u003c= -math.huge or val \u003e= math.huge then\n    error(\"unexpected number value '\" .. tostring(val) .. \"'\")\n  end\n  return string.format(\"%.14g\", val)\nend\n\n\nlocal type_func_map = {\n  [ \"nil\"     ] = encode_nil,\n  [ \"table\"   ] = encode_table,\n  [ \"string\"  ] = encode_string,\n  [ \"number\"  ] = encode_number,\n  [ \"boolean\" ] = tostring,\n}\n\n\nencode = function(val, stack)\n  local t = type(val)\n  local f = type_func_map[t]\n  if f then\n    return f(val, stack)\n  end\n  error(\"unexpected type '\" .. t .. \"'\")\nend\n\n\nfunction json.encode(val)\n  return ( encode(val) )\nend\n\n\n-------------------------------------------------------------------------------\n-- Decode\n-------------------------------------------------------------------------------\n\nlocal parse\n\nlocal function create_set(...)\n  local res = {}\n  for i = 1, select(\"#\", ...) do\n    res[ select(i, ...) ] = true\n  end\n  return res\nend\n\nlocal space_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\")\nlocal delim_chars   = create_set(\" \", \"\\t\", \"\\r\", \"\\n\", \"]\", \"}\", \",\")\nlocal escape_chars  = create_set(\"\\\\\", \"/\", '\"', \"b\", \"f\", \"n\", \"r\", \"t\", \"u\")\nlocal literals      = create_set(\"true\", \"false\", \"null\")\n\nlocal literal_map = {\n  [ \"true\"  ] = true,\n  [ \"false\" ] = false,\n  [ \"null\"  ] = nil,\n}\n\n\nlocal function next_char(str, idx, set, negate)\n  for i = idx, #str do\n    if set[str:sub(i, i)] ~= negate then\n      return i\n    end\n  end\n  return #str + 1\nend\n\n\nlocal function decode_error(str, idx, msg)\n  local line_count = 1\n  local col_count = 1\n  for i = 1, idx - 1 do\n    col_count = col_count + 1\n    if str:sub(i, i) == \"\\n\" then\n      line_count = line_count + 1\n      col_count = 1\n    end\n  end\n  error( string.format(\"%s at line %d col %d\", msg, line_count, col_count) )\nend\n\n\nlocal function codepoint_to_utf8(n)\n  -- http://scripts.sil.org/cms/scripts/page.php?site_id=nrsi\u0026id=iws-appendixa\n  local f = math.floor\n  if n \u003c= 0x7f then\n    return string.char(n)\n  elseif n \u003c= 0x7ff then\n    return string.char(f(n / 64) + 192, n % 64 + 128)\n  elseif n \u003c= 0xffff then\n    return string.char(f(n / 4096) + 224, f(n % 4096 / 64) + 128, n % 64 + 128)\n  elseif n \u003c= 0x10ffff then\n    return string.char(f(n / 262144) + 240, f(n % 262144 / 4096) + 128,\n                       f(n % 4096 / 64) + 128, n % 64 + 128)\n  end\n  error( string.format(\"invalid unicode codepoint '%x'\", n) )\nend\n\n\nlocal function parse_unicode_escape(s)\n  local n1 = tonumber( s:sub(1, 4),  16 )\n  local n2 = tonumber( s:sub(7, 10), 16 )\n   -- Surrogate pair?\n  if n2 then\n    return codepoint_to_utf8((n1 - 0xd800) * 0x400 + (n2 - 0xdc00) + 0x10000)\n  else\n    return codepoint_to_utf8(n1)\n  end\nend\n\n\nlocal function parse_string(str, i)\n  local res = \"\"\n  local j = i + 1\n  local k = j\n\n  while j \u003c= #str do\n    local x = str:byte(j)\n\n    if x \u003c 32 then\n      decode_error(str, j, \"control character in string\")\n\n    elseif x == 92 then -- `\\`: Escape\n      res = res .. str:sub(k, j - 1)\n      j = j + 1\n      local c = str:sub(j, j)\n      if c == \"u\" then\n        local hex = str:match(\"^[dD][89aAbB]%x%x\\\\u%x%x%x%x\", j + 1)\n                 or str:match(\"^%x%x%x%x\", j + 1)\n                 or decode_error(str, j - 1, \"invalid unicode escape in string\")\n        res = res .. parse_unicode_escape(hex)\n        j = j + #hex\n      else\n        if not escape_chars[c] then\n          decode_error(str, j - 1, \"invalid escape char '\" .. c .. \"' in string\")\n        end\n        res = res .. escape_char_map_inv[c]\n      end\n      k = j + 1\n\n    elseif x == 34 then -- `\"`: End of string\n      res = res .. str:sub(k, j - 1)\n      return res, j + 1\n    end\n\n    j = j + 1\n  end\n\n  decode_error(str, i, \"expected closing quote for string\")\nend\n\n\nlocal function parse_number(str, i)\n  local x = next_char(str, i, delim_chars)\n  local s = str:sub(i, x - 1)\n  local n = tonumber(s)\n  if not n then\n    decode_error(str, i, \"invalid number '\" .. s .. \"'\")\n  end\n  return n, x\nend\n\n\nlocal function parse_literal(str, i)\n  local x = next_char(str, i, delim_chars)\n  local word = str:sub(i, x - 1)\n  if not literals[word] then\n    decode_error(str, i, \"invalid literal '\" .. word .. \"'\")\n  end\n  return literal_map[word], x\nend\n\n\nlocal function parse_array(str, i)\n  local res = {}\n  local n = 1\n  i = i + 1\n  while 1 do\n    local x\n    i = next_char(str, i, space_chars, true)\n    -- Empty / end of array?\n    if str:sub(i, i) == \"]\" then\n      i = i + 1\n      break\n    end\n    -- Read token\n    x, i = parse(str, i)\n    res[n] = x\n    n = n + 1\n    -- Next token\n    i = next_char(str, i, space_chars, true)\n    local chr = str:sub(i, i)\n    i = i + 1\n    if chr == \"]\" then break end\n    if chr ~= \",\" then decode_error(str, i, \"expected ']' or ','\") end\n  end\n  return res, i\nend\n\n\nlocal function parse_object(str, i)\n  local res = {}\n  i = i + 1\n  while 1 do\n    local key, val\n    i = next_char(str, i, space_chars, true)\n    -- Empty / end of object?\n    if str:sub(i, i) == \"}\" then\n      i = i + 1\n      break\n    end\n    -- Read key\n    if str:sub(i, i) ~= '\"' then\n      decode_error(str, i, \"expected string for key\")\n    end\n    key, i = parse(str, i)\n    -- Read ':' delimiter\n    i = next_char(str, i, space_chars, true)\n    if str:sub(i, i) ~= \":\" then\n      decode_error(str, i, \"expected ':' after key\")\n    end\n    i = next_char(str, i + 1, space_chars, true)\n    -- Read value\n    val, i = parse(str, i)\n    -- Set\n    res[key] = val\n    -- Next token\n    i = next_char(str, i, space_chars, true)\n    local chr = str:sub(i, i)\n    i = i + 1\n    if chr == \"}\" then break end\n    if chr ~= \",\" then decode_error(str, i, \"expected '}' or ','\") end\n  end\n  return res, i\nend\n\n\nlocal char_func_map = {\n  [ '\"' ] = parse_string,\n  [ \"0\" ] = parse_number,\n  [ \"1\" ] = parse_number,\n  [ \"2\" ] = parse_number,\n  [ \"3\" ] = parse_number,\n  [ \"4\" ] = parse_number,\n  [ \"5\" ] = parse_number,\n  [ \"6\" ] = parse_number,\n  [ \"7\" ] = parse_number,\n  [ \"8\" ] = parse_number,\n  [ \"9\" ] = parse_number,\n  [ \"-\" ] = parse_number,\n  [ \"t\" ] = parse_literal,\n  [ \"f\" ] = parse_literal,\n  [ \"n\" ] = parse_literal,\n  [ \"[\" ] = parse_array,\n  [ \"{\" ] = parse_object,\n}\n\n\nparse = function(str, idx)\n  local chr = str:sub(idx, idx)\n  local f = char_func_map[chr]\n  if f then\n    return f(str, idx)\n  end\n  decode_error(str, idx, \"unexpected character '\" .. chr .. \"'\")\nend\n\n\nfunction json.decode(str)\n  if type(str) ~= \"string\" then\n    error(\"expected argument of type string, got \" .. type(str))\n  end\n  local res, idx = parse(str, next_char(str, 1, space_chars, true))\n  idx = next_char(str, idx, space_chars, true)\n  if idx \u003c= #str then\n    decode_error(str, idx, \"trailing garbage\")\n  end\n  return res\nend\n\n\nreturn json",
    "lrucache.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\n\n-- local lru_new = require(\"resty.lrucache\").new\n-- local resty_lock = require(\"resty.lock\")\n-- local log = require(\"apisix.core.log\")\n-- local tostring = tostring\n-- local concat = table.concat\n-- local ngx = ngx\n-- local get_phase = ngx.get_phase\n\n\n-- local lock_shdict_name = \"lrucache-lock\"\n-- if ngx.config.subsystem == \"stream\" then\n--     lock_shdict_name = lock_shdict_name .. \"-\" .. ngx.config.subsystem\n-- end\n\n\nlocal can_yield_phases = {\n    ssl_session_fetch = true,\n    ssl_session_store = true,\n    rewrite = true,\n    access = true,\n    content = true,\n    timer = true\n}\n\nlocal GLOBAL_ITEMS_COUNT = 1024\nlocal GLOBAL_TTL         = 60 * 60          -- 60 min\nlocal PLUGIN_TTL         = 5 * 60           -- 5 min\nlocal PLUGIN_ITEMS_COUNT = 8\nlocal global_lru_fun\n\n\nlocal function fetch_valid_cache(lru_obj, invalid_stale, item_ttl,\n                                 item_release, key, version)\n    local obj, stale_obj = lru_obj:get(key)\n    if obj and obj.ver == version then\n        return obj\n    end\n\n    if not invalid_stale and stale_obj and stale_obj.ver == version then\n        lru_obj:set(key, stale_obj, item_ttl)\n        return stale_obj\n    end\n\n    if item_release and obj then\n        item_release(obj.val)\n    end\n\n    return nil\nend\n\n-- fake\nlocal function new_lru_fun(opts)\n    return function (key, version, create_obj_fun, ...)\n        local obj, err = create_obj_fun(...)\n        return obj, err\n    end\n\n    -- local item_count, item_ttl\n    -- if opts and opts.type == 'plugin' then\n    --     item_count = opts.count or PLUGIN_ITEMS_COUNT\n    --     item_ttl = opts.ttl or PLUGIN_TTL\n    -- else\n    --     item_count = opts and opts.count or GLOBAL_ITEMS_COUNT\n    --     item_ttl = opts and opts.ttl or GLOBAL_TTL\n    -- end\n\n    -- local item_release = opts and opts.release\n    -- local invalid_stale = opts and opts.invalid_stale\n    -- local serial_creating = opts and opts.serial_creating\n    -- local lru_obj = lru_new(item_count)\n\n    -- return function (key, version, create_obj_fun, ...)\n    --     if not serial_creating or not can_yield_phases[get_phase()] then\n    --         local cache_obj = fetch_valid_cache(lru_obj, invalid_stale,\n    --                             item_ttl, item_release, key, version)\n    --         if cache_obj then\n    --             return cache_obj.val\n    --         end\n\n    --         local obj, err = create_obj_fun(...)\n    --         if obj ~= nil then\n    --             lru_obj:set(key, {val = obj, ver = version}, item_ttl)\n    --         end\n\n    --         return obj, err\n    --     end\n\n    --     local cache_obj = fetch_valid_cache(lru_obj, invalid_stale, item_ttl,\n    --                         item_release, key, version)\n    --     if cache_obj then\n    --         return cache_obj.val\n    --     end\n\n    --     local lock, err = resty_lock:new(lock_shdict_name)\n    --     if not lock then\n    --         return nil, \"failed to create lock: \" .. err\n    --     end\n\n    --     local key_s = tostring(key)\n    --     log.info(\"try to lock with key \", key_s)\n\n    --     local elapsed, err = lock:lock(key_s)\n    --     if not elapsed then\n    --         return nil, \"failed to acquire the lock: \" .. err\n    --     end\n\n    --     cache_obj = fetch_valid_cache(lru_obj, invalid_stale, item_ttl,\n    --                     nil, key, version)\n    --     if cache_obj then\n    --         lock:unlock()\n    --         log.info(\"unlock with key \", key_s)\n    --         return cache_obj.val\n    --     end\n\n    --     local obj, err = create_obj_fun(...)\n    --     if obj ~= nil then\n    --         lru_obj:set(key, {val = obj, ver = version}, item_ttl)\n    --     end\n    --     lock:unlock()\n    --     log.info(\"unlock with key \", key_s)\n\n    --     return obj, err\n    -- end\nend\n\n\nglobal_lru_fun = new_lru_fun()\n\n\nlocal plugin_ctx\ndo\n    local key_buf = {\n        nil,\n        nil,\n        nil,\n    }\n\n    function plugin_ctx(lrucache, api_ctx, extra_key, create_obj_func, ...)\n        key_buf[1] = api_ctx.conf_type\n        key_buf[2] = api_ctx.conf_id\n\n        local key\n        if extra_key then\n            key_buf[3] = extra_key\n            key = concat(key_buf, \"#\", 1, 3)\n        else\n            key = concat(key_buf, \"#\", 1, 2)\n        end\n\n        return lrucache(key, api_ctx.conf_version, create_obj_func, ...)\n    end\nend\n\n\nlocal _M = {\n    version = 0.1,\n    new = new_lru_fun,\n    global = global_lru_fun,\n    plugin_ctx = plugin_ctx,\n}\n\n\nreturn _M\n",
    "plugin.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal _M = {version = 0.2}\n\nlocal json_encode = require(\"apisix.core.json\").encode\n\nfunction _M.run(ctx, plugins)\n    local handle = ctx.handle\n    if not ctx then\n        handle:logWarn(\"no ctx\" )\n        return\n    end\n\n    plugins = plugins or ctx.plugins\n    if not plugins or #plugins == 0 then\n        handle:logWarn(\"no plugins\" )\n        return ctx\n    end\n\n    local phase = ctx.phase\n    local phases = {\n        request = {\n            'access',\n            'rewrite'\n        },\n        response = {\n            'header_filter',\n            'body_filter'\n        }\n    }\n\n    for _, plugin in ipairs(plugins) do\n        local ok, plugin_object = pcall(require, \"apisix.plugins.\" .. plugin.name)\n        if ok then\n            local apisix_phases = phases[phase]\n            for _, phase_name in ipairs(apisix_phases) do\n                local phase_func = plugin_object[phase_name]\n                if phase_func then\n                    local conf = plugin.conf\n                    local status, body = phase_func(conf, ctx)\n                    handle:logWarn(\"phase_name:\" .. phase_name)\n                    handle:logWarn(\"status\" .. status)\n                    if status then\n                        handle:logWarn(\"resp\")\n                        if type(body) == \"table\" then\n                            body = json_encode(body)\n                        end\n                        handle:respond(\n                            {[\":status\"] = status,\n                            -- [\"Location\"] = uri,\n                            [\"server\"] = \"apisix\"},\n                            body or \"\" )\n                        return\n                    end\n                end\n            end\n        else\n            handle:logWarn(\"fail to load plugin:\" .. plugin.name)\n        end\n    end\n\n    return ctx\nend\n\n\nreturn _M\n",
    "re.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal _M = {version = 0.2}\n\nlocal string_match = string.match\n\nfunction _M.parse_uri(_, uri, query_in_path)\n    if query_in_path == nil then query_in_path = true end\n\n    local m, err = string_match(uri, [[^(?:(http[s]?):)?//([^:/\\?]+)(?::(\\d+))?([^\\?]*)\\??(.*)]])\n\n    if not m then\n        if err then\n            return nil, \"failed to match the uri: \" .. uri .. \", \" .. err\n        end\n\n        return nil, \"bad uri: \" .. uri\n    else\n        -- If the URI is schemaless (i.e. //example.com) try to use our current\n        -- request scheme.\n        if not m[1] then\n            return nil, \"schemaless URIs require a request context: \" .. uri\n        end\n\n        if m[3] then\n            m[3] = tonumber(m[3])\n        else\n            if m[1] == \"https\" then\n                m[3] = 443\n            else\n                m[3] = 80\n            end\n        end\n        if not m[4] or \"\" == m[4] then m[4] = \"/\" end\n\n        if query_in_path and m[5] and m[5] ~= \"\" then\n            m[4] = m[4] .. \"?\" .. m[5]\n            m[5] = nil\n        end\n\n        return m, nil\n    end\nend\n\nreturn _M\n",
    "schema.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\n\nlocal jsonschema = {generate_validator = {}}\nlocal lrucache = require(\"apisix.core.lrucache\")\nlocal cached_validator = lrucache.new({count = 1000, ttl = 0})\nlocal pcall = pcall\n\nlocal _M = {\n    version = 0.3,\n    TYPE_CONSUMER = 1,\n}\n\n\nlocal function create_validator(schema)\n    -- local code = jsonschema.generate_validator_code(schema, opts)\n    -- local file2=io.output(\"/tmp/2.txt\")\n    -- file2:write(code)\n    -- file2:close()\n    local ok, res = pcall(jsonschema.generate_validator, schema)\n    if ok then\n        return res\n    end\n\n    return nil, res -- error message\nend\n\nlocal function get_validator(schema)\n    local validator, err = cached_validator(schema, nil,\n                                create_validator, schema)\n\n    if not validator then\n        return nil, err\n    end\n\n    return validator, nil\nend\n\nfunction _M.check(schema, json)\n    local validator, err = get_validator(schema)\n\n    if not validator then\n        return false, err\n    end\n\n    return validator(json)\nend\n\n_M.valid = get_validator\n\nreturn _M\n",
    "string.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal error = error\nlocal type = type\nlocal str_find = string.find\nlocal ffi         = require(\"ffi\")\nlocal C           = ffi.C\nlocal ffi_cast    = ffi.cast\n\n\nffi.cdef[[\n    int memcmp(const void *s1, const void *s2, size_t n);\n]]\n\n\nlocal _M = {\n    version = 0.1,\n}\n\n\nsetmetatable(_M, {__index = string})\n\n\n-- find a needle from a haystack in the plain text way\nfunction _M.find(haystack, needle, from)\n    return str_find(haystack, needle, from or 1, true)\nend\n\n\nfunction _M.has_prefix(s, prefix)\n    if type(s) ~= \"string\" or type(prefix) ~= \"string\" then\n        error(\"unexpected type: s:\" .. type(s) .. \", prefix:\" .. type(prefix))\n    end\n    if #s \u003c #prefix then\n        return false\n    end\n    local rc = C.memcmp(s, prefix, #prefix)\n    return rc == 0\nend\n\n\nfunction _M.has_suffix(s, suffix)\n    if type(s) ~= \"string\" or type(suffix) ~= \"string\" then\n        error(\"unexpected type: s:\" .. type(s) .. \", suffix:\" .. type(suffix))\n    end\n    if #s \u003c #suffix then\n        return false\n    end\n    local rc = C.memcmp(ffi_cast(\"char *\", s) + #s - #suffix, suffix, #suffix)\n    return rc == 0\nend\n\n\nreturn _M\n",
    "table.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nlocal newproxy     = newproxy\nlocal getmetatable = getmetatable\nlocal setmetatable = setmetatable\nlocal select       = select\nlocal new_tab      = require(\"table.new\")\nlocal pairs        = pairs\nlocal type         = type\nlocal string       = string\n\n\nlocal _M = {\n    version = 0.2,\n    new     = new_tab,\n    clear   = require(\"table.clear\"),\n    insert  = table.insert,\n    concat  = table.concat,\n    sort    = table.sort,\n}\n\n\nsetmetatable(_M, {__index = table})\n\n\nlocal nkeys\ndo\n  local ok, table_nkeys = pcall(require, 'table.nkeys')\n  if ok then\n    nkeys = table_nkeys\n  else\n    nkeys = function(t)\n      local count = 0\n      for _, _ in pairs(t) do\n        count = count + 1\n      end\n      return count\n    end\n  end\nend\n_M.nkeys = nkeys\n\n\nfunction _M.insert_tail(tab, ...)\n    local idx = #tab\n    for i = 1, select('#', ...) do\n        idx = idx + 1\n        tab[idx] = select(i, ...)\n    end\n\n    return idx\nend\n\n\nfunction _M.set(tab, ...)\n    for i = 1, select('#', ...) do\n        tab[i] = select(i, ...)\n    end\nend\n\n\n-- only work under lua51 or luajit\nfunction _M.setmt__gc(t, mt)\n    local prox = newproxy(true)\n    getmetatable(prox).__gc = function() mt.__gc(t) end\n    t[prox] = true\n    return setmetatable(t, mt)\nend\n\n\nlocal function deepcopy(orig)\n    local orig_type = type(orig)\n    if orig_type ~= 'table' then\n        return orig\n    end\n\n    -- If the array-like table contains nil in the middle,\n    -- the len might be smaller than the expected.\n    -- But it doesn't affect the correctness.\n    local len = #orig\n    local copy = new_tab(len, nkeys(orig) - len)\n    for orig_key, orig_value in pairs(orig) do\n        copy[orig_key] = deepcopy(orig_value)\n    end\n\n    return copy\nend\n_M.deepcopy = deepcopy\n\nlocal ngx_null = nil\nlocal function merge(origin, extend)\n    for k,v in pairs(extend) do\n        if type(v) == \"table\" then\n            if type(origin[k] or false) == \"table\" then\n                if _M.nkeys(origin[k]) ~= #origin[k] then\n                    merge(origin[k] or {}, extend[k] or {})\n                else\n                    origin[k] = v\n                end\n            else\n                origin[k] = v\n            end\n        elseif v == ngx_null then\n            origin[k] = nil\n        else\n            origin[k] = v\n        end\n    end\n\n    return origin\nend\n_M.merge = merge\n\n\nlocal function patch(node_value, sub_path, conf)\n    local sub_value = node_value\n    local sub_paths = string.split(sub_path, \"/\")\n    for i = 1, #sub_paths - 1 do\n        local sub_name = sub_paths[i]\n        if sub_value[sub_name] == nil then\n            sub_value[sub_name] = {}\n        end\n\n        sub_value = sub_value[sub_name]\n\n        if type(sub_value) ~= \"table\" then\n            return 400, \"invalid sub-path: /\"\n                      .. _M.concat(sub_paths, 1, i)\n        end\n    end\n\n    if type(sub_value) ~= \"table\" then\n        return 400, \"invalid sub-path: /\" .. sub_path\n    end\n\n    local sub_name = sub_paths[#sub_paths]\n    if sub_name and sub_name ~= \"\" then\n        sub_value[sub_name] = conf\n    else\n        node_value = conf\n    end\n\n    return nil, nil, node_value\nend\n_M.patch = patch\n\n\nreturn _M\n",
    "version.lua": "--\n-- Licensed to the Apache Software Foundation (ASF) under one or more\n-- contributor license agreements.  See the NOTICE file distributed with\n-- this work for additional information regarding copyright ownership.\n-- The ASF licenses this file to You under the Apache License, Version 2.0\n-- (the \"License\"); you may not use this file except in compliance with\n-- the License.  You may obtain a copy of the License at\n--\n--     http://www.apache.org/licenses/LICENSE-2.0\n--\n-- Unless required by applicable law or agreed to in writing, software\n-- distributed under the License is distributed on an \"AS IS\" BASIS,\n-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n-- See the License for the specific language governing permissions and\n-- limitations under the License.\n--\nreturn {\n    VERSION = \"0.1.0\"\n}\n"
  }
}