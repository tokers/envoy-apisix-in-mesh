{
  "kind": "ConfigMap",
  "apiVersion": "v1",
  "metadata": {
    "name": "envoy-apisix-configmap-3",
    "creationTimestamp": null
  },
  "data": {
    "url.lua": "-- neturl.lua - a robust url parser and builder\n--\n-- Bertrand Mansion, 2011-2013; License MIT\n-- @module neturl\n-- @alias\tM\n\nlocal M = {}\nM.version = \"0.9.0\"\n\n--- url options\n-- separator is set to `\u0026` by default but could be anything like `\u0026amp;amp;` or `;`\n-- @todo Add an option to limit the size of the argument table\nM.options = {\n\tseparator = '\u0026'\n}\n\n--- list of known and common scheme ports\n-- as documented in \u003ca href=\"http://www.iana.org/assignments/uri-schemes.html\"\u003eIANA URI scheme list\u003c/a\u003e\nM.services = {\n\tacap     = 674,\n\tcap      = 1026,\n\tdict     = 2628,\n\tftp      = 21,\n\tgopher   = 70,\n\thttp     = 80,\n\thttps    = 443,\n\tiax      = 4569,\n\ticap     = 1344,\n\timap     = 143,\n\tipp      = 631,\n\tldap     = 389,\n\tmtqp     = 1038,\n\tmupdate  = 3905,\n\tnews     = 2009,\n\tnfs      = 2049,\n\tnntp     = 119,\n\trtsp     = 554,\n\tsip      = 5060,\n\tsnmp     = 161,\n\ttelnet   = 23,\n\ttftp     = 69,\n\tvemmi    = 575,\n\tafs      = 1483,\n\tjms      = 5673,\n\trsync    = 873,\n\tprospero = 191,\n\tvideotex = 516\n}\n\nlocal legal = {\n\t[\"-\"] = true, [\"_\"] = true, [\".\"] = true, [\"!\"] = true,\n\t[\"~\"] = true, [\"*\"] = true, [\"'\"] = true, [\"(\"] = true,\n\t[\")\"] = true, [\":\"] = true, [\"@\"] = true, [\"\u0026\"] = true,\n\t[\"=\"] = true, [\"+\"] = true, [\"$\"] = true, [\",\"] = true,\n\t[\";\"] = true -- can be used for parameters in path\n}\n\nlocal function decode(str, path)\n\tlocal str = str\n\tif not path then\n\t\tstr = str:gsub('+', ' ')\n\tend\n\treturn (str:gsub(\"%%(%x%x)\", function(c)\n\t\t\treturn string.char(tonumber(c, 16))\n\tend))\nend\n\nlocal function encode(str)\n\treturn (str:gsub(\"([^A-Za-z0-9%_%.%-%~])\", function(v)\n\t\t\treturn string.upper(string.format(\"%%%02x\", string.byte(v)))\n\tend))\nend\n\n-- for query values, prefer + instead of %20 for spaces\nlocal function encodeValue(str)\n\tlocal str = encode(str)\n\treturn str:gsub('%%20', '+')\nend\n\nlocal function encodeSegment(s)\n\tlocal legalEncode = function(c)\n\t\tif legal[c] then\n\t\t\treturn c\n\t\tend\n\t\treturn encode(c)\n\tend\n\treturn s:gsub('([^a-zA-Z0-9])', legalEncode)\nend\n\nlocal function concat(s, u)\n\treturn s .. u:build()\nend\n\n--- builds the url\n-- @return a string representing the built url\nfunction M:build()\n\tlocal url = ''\n\tif self.path then\n\t\tlocal path = self.path\n\t\tpath:gsub(\"([^/]+)\", function (s) return encodeSegment(s) end)\n\t\turl = url .. tostring(path)\n\tend\n\tif self.query then\n\t\tlocal qstring = tostring(self.query)\n\t\tif qstring ~= \"\" then\n\t\t\turl = url .. '?' .. qstring\n\t\tend\n\tend\n\tif self.host then\n\t\tlocal authority = self.host\n\t\tif self.port and self.scheme and M.services[self.scheme] ~= self.port then\n\t\t\tauthority = authority .. ':' .. self.port\n\t\tend\n\t\tlocal userinfo\n\t\tif self.user and self.user ~= \"\" then\n\t\t\tuserinfo = self.user\n\t\t\tif self.password then\n\t\t\t\tuserinfo = userinfo .. ':' .. self.password\n\t\t\tend\n\t\tend\n\t\tif userinfo and userinfo ~= \"\" then\n\t\t\tauthority = userinfo .. '@' .. authority\n\t\tend\n\t\tif authority then\n\t\t\tif url ~= \"\" then\n\t\t\t\turl = '//' .. authority .. '/' .. url:gsub('^/+', '')\n\t\t\telse\n\t\t\t\turl = '//' .. authority\n\t\t\tend\n\t\tend\n\tend\n\tif self.scheme then\n\t\turl = self.scheme .. ':' .. url\n\tend\n\tif self.fragment then\n\t\turl = url .. '#' .. self.fragment\n\tend\n\treturn url\nend\n\n--- builds the querystring\n-- @param tab The key/value parameters\n-- @param sep The separator to use (optional)\n-- @param key The parent key if the value is multi-dimensional (optional)\n-- @return a string representing the built querystring\nfunction M.buildQuery(tab, sep, key)\n\tlocal query = {}\n\tif not sep then\n\t\tsep = M.options.separator or '\u0026'\n\tend\n\tlocal keys = {}\n\tfor k in pairs(tab) do\n\t\tkeys[#keys+1] = k\n\tend\n\ttable.sort(keys)\n\tfor _,name in ipairs(keys) do\n\t\tlocal value = tab[name]\n\t\tname = encode(tostring(name))\n\t\tif key then\n\t\t\tname = string.format('%s[%s]', tostring(key), tostring(name))\n\t\tend\n\t\tif type(value) == 'table' then\n\t\t\tquery[#query+1] = M.buildQuery(value, sep, name)\n\t\telse\n\t\t\tlocal value = encodeValue(tostring(value))\n\t\t\tif value ~= \"\" then\n\t\t\t\tquery[#query+1] = string.format('%s=%s', name, value)\n\t\t\telse\n\t\t\t\tquery[#query+1] = name\n\t\t\tend\n\t\tend\n\tend\n\treturn table.concat(query, sep)\nend\n\n--- Parses the querystring to a table\n-- This function can parse multidimensional pairs and is mostly compatible\n-- with PHP usage of brackets in key names like ?param[key]=value\n-- @param str The querystring to parse\n-- @param sep The separator between key/value pairs, defaults to `\u0026`\n-- @todo limit the max number of parameters with M.options.max_parameters\n-- @return a table representing the query key/value pairs\nfunction M.parseQuery(str, sep)\n\tif not sep then\n\t\tsep = M.options.separator or '\u0026'\n\tend\n\n\tlocal values = {}\n\tfor key,val in str:gmatch(string.format('([^%q=]+)(=*[^%q=]*)', sep, sep)) do\n\t\tlocal key = decode(key)\n\t\tlocal keys = {}\n\t\tkey = key:gsub('%[([^%]]*)%]', function(v)\n\t\t\t\t-- extract keys between balanced brackets\n\t\t\t\tif string.find(v, \"^-?%d+$\") then\n\t\t\t\t\tv = tonumber(v)\n\t\t\t\telse\n\t\t\t\t\tv = decode(v)\n\t\t\t\tend\n\t\t\t\ttable.insert(keys, v)\n\t\t\t\treturn \"=\"\n\t\tend)\n\t\tkey = key:gsub('=+.*$', \"\")\n\t\tkey = key:gsub('%s', \"_\") -- remove spaces in parameter name\n\t\tval = val:gsub('^=+', \"\")\n\n\t\tif not values[key] then\n\t\t\tvalues[key] = {}\n\t\tend\n\t\tif #keys \u003e 0 and type(values[key]) ~= 'table' then\n\t\t\tvalues[key] = {}\n\t\telseif #keys == 0 and type(values[key]) == 'table' then\n\t\t\tvalues[key] = decode(val)\n\t\tend\n\n\t\tlocal t = values[key]\n\t\tfor i,k in ipairs(keys) do\n\t\t\tif type(t) ~= 'table' then\n\t\t\t\tt = {}\n\t\t\tend\n\t\t\tif k == \"\" then\n\t\t\t\tk = #t+1\n\t\t\tend\n\t\t\tif not t[k] then\n\t\t\t\tt[k] = {}\n\t\t\tend\n\t\t\tif i == #keys then\n\t\t\t\tt[k] = decode(val)\n\t\t\tend\n\t\t\tt = t[k]\n\t\tend\n\tend\n\tsetmetatable(values, { __tostring = M.buildQuery })\n\treturn values\nend\n\n--- set the url query\n-- @param query Can be a string to parse or a table of key/value pairs\n-- @return a table representing the query key/value pairs\nfunction M:setQuery(query)\n\tlocal query = query\n\tif type(query) == 'table' then\n\t\tquery = M.buildQuery(query)\n\tend\n\tself.query = M.parseQuery(query)\n\treturn query\nend\n\n--- set the authority part of the url\n-- The authority is parsed to find the user, password, port and host if available.\n-- @param authority The string representing the authority\n-- @return a string with what remains after the authority was parsed\nfunction M:setAuthority(authority)\n\tself.authority = authority\n\tself.port = nil\n\tself.host = nil\n\tself.userinfo = nil\n\tself.user = nil\n\tself.password = nil\n\n\tauthority = authority:gsub('^([^@]*)@', function(v)\n\t\tself.userinfo = v\n\t\treturn ''\n\tend)\n\tauthority = authority:gsub(\"^%[[^%]]+%]\", function(v)\n\t\t-- ipv6\n\t\tself.host = v\n\t\treturn ''\n\tend)\n\tauthority = authority:gsub(':([^:]*)$', function(v)\n\t\tself.port = tonumber(v)\n\t\treturn ''\n\tend)\n\tif authority ~= '' and not self.host then\n\t\tself.host = authority:lower()\n\tend\n\tif self.userinfo then\n\t\tlocal userinfo = self.userinfo\n\t\tuserinfo = userinfo:gsub(':([^:]*)$', function(v)\n\t\t\t\tself.password = v\n\t\t\t\treturn ''\n\t\tend)\n\t\tself.user = userinfo\n\tend\n\treturn authority\nend\n\n--- Parse the url into the designated parts.\n-- Depending on the url, the following parts can be available:\n-- scheme, userinfo, user, password, authority, host, port, path,\n-- query, fragment\n-- @param url Url string\n-- @return a table with the different parts and a few other functions\nfunction M.parse(url)\n\tlocal comp = {}\n\tM.setAuthority(comp, \"\")\n\tM.setQuery(comp, \"\")\n\n\tlocal url = tostring(url or '')\n\turl = url:gsub('#(.*)$', function(v)\n\t\tcomp.fragment = v\n\t\treturn ''\n\tend)\n\turl =url:gsub('^([%w][%w%+%-%.]*)%:', function(v)\n\t\tcomp.scheme = v:lower()\n\t\treturn ''\n\tend)\n\turl = url:gsub('%?(.*)', function(v)\n\t\tM.setQuery(comp, v)\n\t\treturn ''\n\tend)\n\turl = url:gsub('^//([^/]*)', function(v)\n\t\tM.setAuthority(comp, v)\n\t\treturn ''\n\tend)\n\tcomp.path = decode(url, true)\n\n\tsetmetatable(comp, {\n\t\t__index = M,\n\t\t__concat = concat,\n\t\t__tostring = M.build}\n\t)\n\treturn comp\nend\n\n--- removes dots and slashes in urls when possible\n-- This function will also remove multiple slashes\n-- @param path The string representing the path to clean\n-- @return a string of the path without unnecessary dots and segments\nfunction M.removeDotSegments(path)\n\tlocal fields = {}\n\tif string.len(path) == 0 then\n\t\treturn \"\"\n\tend\n\tlocal startslash = false\n\tlocal endslash = false\n\tif string.sub(path, 1, 1) == \"/\" then\n\t\tstartslash = true\n\tend\n\tif (string.len(path) \u003e 1 or startslash == false) and string.sub(path, -1) == \"/\" then\n\t\tendslash = true\n\tend\n\n\tpath:gsub('[^/]+', function(c) table.insert(fields, c) end)\n\n\tlocal new = {}\n\tlocal j = 0\n\n\tfor i,c in ipairs(fields) do\n\t\tif c == '..' then\n\t\t\tif j \u003e 0 then\n\t\t\t\tj = j - 1\n\t\t\tend\n\t\telseif c ~= \".\" then\n\t\t\tj = j + 1\n\t\t\tnew[j] = c\n\t\tend\n\tend\n\tlocal ret = \"\"\n\tif #new \u003e 0 and j \u003e 0 then\n\t\tret = table.concat(new, '/', 1, j)\n\telse\n\t\tret = \"\"\n\tend\n\tif startslash then\n\t\tret = '/'..ret\n\tend\n\tif endslash then\n\t\tret = ret..'/'\n\tend\n\treturn ret\nend\n\nlocal function absolutePath(base_path, relative_path)\n\tif string.sub(relative_path, 1, 1) == \"/\" then\n\t\treturn '/' .. string.gsub(relative_path, '^[%./]+', '')\n\tend\n\tlocal path = base_path\n\tif relative_path ~= \"\" then\n\t\tpath = '/'..path:gsub(\"[^/]*$\", \"\")\n\tend\n\tpath = path .. relative_path\n\tpath = path:gsub(\"([^/]*%./)\", function (s)\n\t\tif s ~= \"./\" then return s else return \"\" end\n\tend)\n\tpath = string.gsub(path, \"/%.$\", \"/\")\n\tlocal reduced\n\twhile reduced ~= path do\n\t\treduced = path\n\t\tpath = string.gsub(reduced, \"([^/]*/%.%./)\", function (s)\n\t\t\tif s ~= \"../../\" then return \"\" else return s end\n\t\tend)\n\tend\n\tpath = string.gsub(path, \"([^/]*/%.%.?)$\", function (s)\n\t\tif s ~= \"../..\" then return \"\" else return s end\n\tend)\n\tlocal reduced\n\twhile reduced ~= path do\n\t\treduced = path\n\t\tpath = string.gsub(reduced, '^/?%.%./', '')\n\tend\n\treturn '/' .. path\nend\n\n--- builds a new url by using the one given as parameter and resolving paths\n-- @param other A string or a table representing a url\n-- @return a new url table\nfunction M:resolve(other)\n\tif type(self) == \"string\" then\n\t\tself = M.parse(self)\n\tend\n\tif type(other) == \"string\" then\n\t\tother = M.parse(other)\n\tend\n\tif other.scheme then\n\t\treturn other\n\telse\n\t\tother.scheme = self.scheme\n\t\tif not other.authority or other.authority == \"\" then\n\t\t\tother:setAuthority(self.authority)\n\t\t\tif not other.path or other.path == \"\" then\n\t\t\t\tother.path = self.path\n\t\t\t\tlocal query = other.query\n\t\t\t\tif not query or not next(query) then\n\t\t\t\t\tother.query = self.query\n\t\t\t\tend\n\t\t\telse\n\t\t\t\tother.path = absolutePath(self.path, other.path)\n\t\t\tend\n\t\tend\n\t\treturn other\n\tend\nend\n\n--- normalize a url path following some common normalization rules\n-- described on \u003ca href=\"http://en.wikipedia.org/wiki/URL_normalization\"\u003eThe URL normalization page of Wikipedia\u003c/a\u003e\n-- @return the normalized path\nfunction M:normalize()\n\tif type(self) == 'string' then\n\t\tself = M.parse(self)\n\tend\n\tif self.path then\n\t\tlocal path = self.path\n\t\tpath = absolutePath(path, \"\")\n\t\t-- normalize multiple slashes\n\t\tpath = string.gsub(path, \"//+\", \"/\")\n\t\tself.path = path\n\tend\n\treturn self\nend\n\nreturn M"
  }
}